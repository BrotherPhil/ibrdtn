/*
 * ClientSession.java
 * 
 * Copyright (C) 2011 IBR, TU Braunschweig
 *
 * Written-by: Johannes Morgenroth <morgenroth@ibr.cs.tu-bs.de>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package de.tubs.ibr.dtn.service;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;

import android.content.Context;
import android.content.Intent;
import android.os.ParcelFileDescriptor;
import android.os.RemoteException;
import android.util.Log;
import de.tubs.ibr.dtn.api.Bundle;
import de.tubs.ibr.dtn.api.BundleID;
import de.tubs.ibr.dtn.api.DTNSession;
import de.tubs.ibr.dtn.api.DTNSessionCallback;
import de.tubs.ibr.dtn.api.EID;
import de.tubs.ibr.dtn.api.GroupEndpoint;
import de.tubs.ibr.dtn.api.Registration;
import de.tubs.ibr.dtn.api.SessionDestroyedException;
import de.tubs.ibr.dtn.api.SingletonEndpoint;
import de.tubs.ibr.dtn.swig.NativeSession;
import de.tubs.ibr.dtn.swig.PrimaryBlock;
import de.tubs.ibr.dtn.swig.NativeSession.RegisterIndex;
import de.tubs.ibr.dtn.swig.NativeSessionCallback;

public class ClientSession {

	private final static String TAG = "ClientSession";

	private String _package_name = null;

	private Context context = null;
	private APISession _session = null;
	private Registration _registration = null;

	private Boolean _daemon_online = false;

	/**
	 * Implemented C++ callback using SWIG directors
	 * 
	 * see http://stackoverflow.com/questions/8168517/generating-java-interface-
	 * with-swig/8246375#8246375
	 */
	private class NativeSessionCallbackImpl extends NativeSessionCallback {

		// TODO: override!

	};

	private NativeSession nativeSession = new NativeSession(new NativeSessionCallbackImpl());

	public ClientSession(Context context, Registration reg, String packageName) {
		// create a unique session key
		this.context = context;
		this._package_name = packageName;
		this._registration = reg;
	}

	/*
	 * Delegating these methods to NativeSession generated by SWIG
	 */

	public void setEndpoint(String id)
	{
		nativeSession.setEndpoint(id);
	}

	public void addRegistration(GroupEndpoint eid)
	{
		de.tubs.ibr.dtn.swig.EID swigEid = new de.tubs.ibr.dtn.swig.EID(eid.toString());
		nativeSession.addRegistration(swigEid);
	}

	public void getBundle()
	{
		nativeSession.get(de.tubs.ibr.dtn.swig.NativeSession.RegisterIndex.REG1);

		// TODO: read?!
	}

	public void loadBundle(BundleID id)
	{
		de.tubs.ibr.dtn.swig.BundleID swigId = new de.tubs.ibr.dtn.swig.BundleID();
		swigId.setSource(new de.tubs.ibr.dtn.swig.EID(id.getSource()));
		swigId.setSequencenumber(id.getSequencenumber());

		Timestamp ts = new Timestamp(id.getTimestamp());
		swigId.setTimestamp(ts.getValue());

		nativeSession.load(de.tubs.ibr.dtn.swig.NativeSession.RegisterIndex.REG1, swigId);
	}

	public void loadAndGetBundle()
	{
		// get next bundle in the queue
		nativeSession.next(de.tubs.ibr.dtn.swig.NativeSession.RegisterIndex.REG1);
	}

	public void markDelivered(BundleID id)
	{
		de.tubs.ibr.dtn.swig.BundleID swigId = new de.tubs.ibr.dtn.swig.BundleID();
		swigId.setSource(new de.tubs.ibr.dtn.swig.EID(id.getSource()));
		swigId.setSequencenumber(id.getSequencenumber());

		Timestamp ts = new Timestamp(id.getTimestamp());
		swigId.setTimestamp(ts.getValue());

		nativeSession.delivered(swigId);
	}

	/**
	 * Put Bundle into NativeSession
	 */
	public synchronized void put(Bundle bundle)
	{
		/*
		 * Convert API Bundle to SWIG bundle
		 */
		de.tubs.ibr.dtn.swig.PrimaryBlock swigPrimaryBlock = new de.tubs.ibr.dtn.swig.PrimaryBlock();
		swigPrimaryBlock.set_custodian(new de.tubs.ibr.dtn.swig.EID(bundle.custodian));
		swigPrimaryBlock.set_destination(new de.tubs.ibr.dtn.swig.EID(bundle.destination));
		swigPrimaryBlock.set_fragmentoffset(bundle.fragment_offset);
		swigPrimaryBlock.set_lifetime(bundle.lifetime);
		swigPrimaryBlock.set_procflags(bundle.procflags);
		swigPrimaryBlock.set_reportto(new de.tubs.ibr.dtn.swig.EID(bundle.reportto));
		swigPrimaryBlock.set_sequencenumber(bundle.sequencenumber);
		swigPrimaryBlock.set_source(new de.tubs.ibr.dtn.swig.EID(bundle.source));

		Timestamp ts = new Timestamp(bundle.timestamp);
		swigPrimaryBlock.set_timestamp(ts.getValue());

		// TODO: priority
		swigPrimaryBlock.setPriority(de.tubs.ibr.dtn.swig.PrimaryBlock.PRIORITY.PRIO_MEDIUM);

		// put it into native session
		nativeSession.put(de.tubs.ibr.dtn.swig.NativeSession.RegisterIndex.REG1, swigPrimaryBlock);
	}

	public void writeAndSend(byte[] data)
	{
		nativeSession.write(de.tubs.ibr.dtn.swig.NativeSession.RegisterIndex.REG1, data);

		nativeSession.send(de.tubs.ibr.dtn.swig.NativeSession.RegisterIndex.REG1);
	}

	public void writeAndSend(InputStream stream, Long length)
	{
		// read input as buffered stream and write into NativeSession Bundle
		byte[] buf = new byte[8192];
		int len;
		int total = 0;
		try
		{
			while ((len = stream.read(buf, 0, Math.min(buf.length, (int) Math.min(Integer.MAX_VALUE, length - total)))) > 0)
			{
				total += len;

				nativeSession.write(de.tubs.ibr.dtn.swig.NativeSession.RegisterIndex.REG1, buf, Long.valueOf(0));
				// out.write(buf, 0, len);
			}
		} catch (IOException e)
		{
			Log.e(TAG, "Writing into NativeSession bundle failed!", e);
		}

		nativeSession.send(de.tubs.ibr.dtn.swig.NativeSession.RegisterIndex.REG1);
	}

	/**
	 * Send a bundle directly to the daemon.
	 * 
	 * @param destination
	 *            The destination of the bundle.
	 * @param lifetime
	 *            The lifetime of the bundle.
	 * @param data
	 *            The payload as byte-array.
	 * @throws APIException
	 *             If the transmission fails.
	 */
	public void send(EID destination, int lifetime, byte[] data)
	{
		// send(destination, lifetime, data, Bundle.Priority.NORMAL);

		Bundle bundle = new Bundle();
		if (destination instanceof GroupEndpoint)
		{
			bundle.procflags = (long) 16;
		} else
		{
			bundle.procflags = (long) 0;
		}
		bundle.destination = destination.toString();
		bundle.lifetime = Long.valueOf(lifetime);

		// put it into native session
		put(bundle);

		writeAndSend(data);
	}

	/**
	 * Send a bundle directly to the daemon.
	 * 
	 * @param destination
	 *            The destination of the bundle.
	 * @param lifetime
	 *            The lifetime of the bundle.
	 * @param data
	 *            The payload as byte-array.
	 * @param priority
	 *            The priority of the bundle
	 * @throws APIException
	 *             If the transmission fails.
	 */
	// public void send(EID destination, Integer lifetime, byte[] data,
	// Bundle.Priority priority)
	// {
	// wrapper to the send(Bundle) function
	// Bundle bundle = new Bundle(destination, lifetime);
	// bundle.appendBlock(new PayloadBlock(data));
	// bundle.setPriority(priority);
	// send(bundle);
	// }

	/**
	 * Send a bundle directly to the daemon. The given stream is used as payload
	 * of the bundle.
	 * 
	 * @param destination
	 *            The destination of the bundle.
	 * @param lifetime
	 *            The lifetime of the bundle.
	 * @param stream
	 *            The stream containing the payload data.
	 * @param length
	 *            The length of the payload.
	 * @throws APIException
	 *             If the transmission fails.
	 */
	public void send(EID destination, int lifetime, InputStream stream, Long length)
	{
		// send(destination, lifetime, stream, length, Bundle.Priority.NORMAL);

		Bundle bundle = new Bundle();
		if (destination instanceof GroupEndpoint)
		{
			bundle.procflags = (long) 16;
		} else
		{
			bundle.procflags = (long) 0;
		}
		bundle.destination = destination.toString();
		bundle.lifetime = Long.valueOf(lifetime);

		// put it into native session
		put(bundle);

		writeAndSend(stream, length);
	}

	/**
	 * Send a bundle directly to the daemon. The given stream is used as payload
	 * of the bundle.
	 * 
	 * @param destination
	 *            The destination of the bundle.
	 * @param lifetime
	 *            The lifetime of the bundle.
	 * @param stream
	 *            The stream containing the payload data.
	 * @param length
	 *            The length of the payload.
	 * @param priority
	 *            The priority of the bundle
	 * @throws APIException
	 *             If the transmission fails.
	 */
	// public void send(EID destination, Integer lifetime, InputStream stream,
	// Long length, Bundle.Priority priority)
	// {
	// Bundle bundle = new Bundle(destination, lifetime);
	// bundle.appendBlock(new PayloadBlock(new InputStreamBlockData(stream,
	// length)));
	// bundle.setPriority(priority);
	// send(bundle);
	// }

	public synchronized void initialize()
	{
		_daemon_online = true;
		_initialize_process.start();

		// TODO: We need to register!
		// this was done by _session.register(_registration);
		// invoke_registration_intent();
	}

	private Thread _initialize_process = new Thread() {
		@Override
		public void run()
		{
			try
			{
				while (!isInterrupted())
				{
					try
					{
						getSession();
						break;
					} catch (IOException e)
					{
						synchronized (ClientSession.this)
						{
							wait(5000);
						}
					}
				}
			} catch (InterruptedException e1)
			{
			}
		}
	};

	public synchronized void terminate()
	{
		_daemon_online = false;
		_initialize_process.interrupt();

		if (_session != null)
		{
			_session.disconnect();
			_session = null;
		}
	}

	private synchronized APISession getSession() throws IOException
	{
		if (!_daemon_online) throw new IOException("daemon is offline");

//		try
//		{
			if (_session == null)
			{
				Log.d(TAG, "try to create an API session with the daemon");
				_session = new APISession(this);

				// APIConnection socket = this._manager.getAPIConnection();
				// if (socket == null) throw new
				// IOException("daemon not running");

				// _session.connect(socket);
				_session.connect();
				_session.register(_registration);

				invoke_registration_intent();
			}

			if (_session.isConnected())
			{
				return _session;
			} else
			{
				_session = null;
				throw new IOException("not connected");
			}
//		} catch (APIException e)
//		{
//			_session = null;
//			throw new IOException("api error");
//		}
	}

	private final DTNSession.Stub mBinder = new DTNSession.Stub() {
		public boolean query(DTNSessionCallback cb, BundleID id) throws RemoteException
		{
			try
			{
				APISession session = getSession();
				session.query(cb, id);
				return true;
			} catch (Exception e)
			{
				Log.e(TAG, "query failed", e);
				return false;
			}
		}

		public boolean queryNext(DTNSessionCallback cb) throws RemoteException
		{
			try
			{
				APISession session = getSession();
				return session.query(cb);
			} catch (Exception e)
			{
				Log.e(TAG, "queryNext failed", e);
				return false;
			}
		}

		public boolean delivered(BundleID id) throws RemoteException
		{
			try
			{
				APISession session = getSession();
				session.setDelivered(id);
				return true;
			} catch (Exception e)
			{
				Log.e(TAG, "delivered failed", e);
				return false;
			}
		}

		public boolean send(SingletonEndpoint destination, int lifetime, byte[] data) throws RemoteException
		{
			try
			{
				APISession session = getSession();
				return session.send(destination, lifetime, data);
			} catch (Exception e)
			{
				Log.e(TAG, "send failed", e);
				return false;
			}
		}

		public boolean sendGroup(GroupEndpoint destination, int lifetime, byte[] data) throws RemoteException
		{
			try
			{
				APISession session = getSession();
				return session.send(destination, lifetime, data);
			} catch (Exception e)
			{
				Log.e(TAG, "sendGroup failed", e);
				return false;
			}
		}

		public boolean sendFileDescriptor(SingletonEndpoint destination, int lifetime, ParcelFileDescriptor fd, long length) throws RemoteException
		{
			try
			{
				APISession session = getSession();
				return session.send(destination, lifetime, fd, length);
			} catch (Exception e)
			{
				Log.e(TAG, "sendFileDescriptor failed", e);
				return false;
			}
		}

		public boolean sendGroupFileDescriptor(GroupEndpoint destination, int lifetime, ParcelFileDescriptor fd, long length) throws RemoteException
		{
			try
			{
				APISession session = getSession();
				return session.send(destination, lifetime, fd, length);
			} catch (Exception e)
			{
				Log.e(TAG, "sendGroupFileDescriptor failed", e);
				return false;
			}
		}
	};

	public DTNSession getBinder()
	{
		return mBinder;
	}

	public String getPackageName()
	{
		return _package_name;
	}

	// public synchronized void invoke_reconnect()
	// {
	// _session = null;
	// }

	public void invoke_receive_intent(BundleID id)
	{
		// forward the notification as intent
		// create a new intent
		Intent notify = new Intent(de.tubs.ibr.dtn.Intent.RECEIVE);
		notify.addCategory(_package_name);
		notify.putExtra("type", "bundle");
		notify.putExtra("data", id);

		// send notification intent
		context.sendBroadcast(notify);

		Log.d(TAG, "RECEIVE intent sent to " + _package_name);
	}

	private void invoke_registration_intent()
	{
		// send out registration intent to the application
		Intent broadcastIntent = new Intent(de.tubs.ibr.dtn.Intent.REGISTRATION);
		broadcastIntent.addCategory(_package_name);
		broadcastIntent.putExtra("key", _package_name);

		// send notification intent
		context.sendBroadcast(broadcastIntent);

		Log.d(TAG, "REGISTRATION intent sent to " + _package_name);
	}
}
